"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getCSFLELibraryPaths = exports.SHARED_LIBRARY_SUFFIX = void 0;
const path_1 = __importDefault(require("path"));
const fs_1 = require("fs");
exports.SHARED_LIBRARY_SUFFIX = process.platform === 'win32' ? 'dll' :
    process.platform === 'darwin' ? 'dylib' : 'so';
async function getCSFLELibraryPaths(bus, pretendProcessExecPathForTesting = undefined) {
    const execPath = pretendProcessExecPathForTesting !== null && pretendProcessExecPathForTesting !== void 0 ? pretendProcessExecPathForTesting : process.execPath;
    let getCSFLESharedLibraryVersion;
    try {
        getCSFLESharedLibraryVersion = require('mongodb-csfle-library-version');
    }
    catch (err) {
        getCSFLESharedLibraryVersion = () => ({ version: BigInt(0), versionStr: '<unknown>' });
    }
    if (execPath === process.argv[1] || pretendProcessExecPathForTesting) {
        const bindir = path_1.default.dirname(execPath);
        const execPathStat = await fs_1.promises.stat(execPath);
        for await (const libraryCandidate of [
            path_1.default.resolve(bindir, '..', 'lib64', `mongosh_csfle_v1.${exports.SHARED_LIBRARY_SUFFIX}`),
            path_1.default.resolve(bindir, '..', 'lib', `mongosh_csfle_v1.${exports.SHARED_LIBRARY_SUFFIX}`),
            path_1.default.resolve(bindir, `mongosh_csfle_v1.${exports.SHARED_LIBRARY_SUFFIX}`)
        ]) {
            try {
                const permissionsMismatch = await ensureMatchingPermissions(libraryCandidate, execPathStat);
                if (permissionsMismatch) {
                    bus.emit('mongosh:csfle-load-skip', {
                        csflePath: libraryCandidate,
                        reason: 'permissions mismatch',
                        details: permissionsMismatch
                    });
                    continue;
                }
                const version = getCSFLESharedLibraryVersion(libraryCandidate);
                const result = {
                    csflePath: libraryCandidate,
                    expectedVersion: version
                };
                bus.emit('mongosh:csfle-load-found', result);
                return result;
            }
            catch (err) {
                bus.emit('mongosh:csfle-load-skip', {
                    csflePath: libraryCandidate,
                    reason: err.message
                });
            }
        }
    }
    else {
        bus.emit('mongosh:csfle-load-skip', {
            csflePath: '',
            reason: 'Skipping CSFLE library searching because this is not a single-executable mongosh'
        });
    }
    return {};
}
exports.getCSFLELibraryPaths = getCSFLELibraryPaths;
async function ensureMatchingPermissions(filename, execPathStat) {
    if (process.platform === 'win32') {
        return null;
    }
    await fs_1.promises.access(filename, fs_1.constants.R_OK);
    const stat = await fs_1.promises.stat(filename);
    if (((stat.uid !== execPathStat.uid && stat.uid !== process.getuid()) ||
        (stat.gid !== execPathStat.gid && stat.gid !== process.getgid()) ||
        stat.mode & 0o002)) {
        return {
            libraryStat: { uid: stat.uid, gid: stat.gid, mode: stat.mode },
            mongoshStat: { uid: execPathStat.uid, gid: stat.gid },
            currentUser: { uid: process.getuid(), gid: process.getgid() }
        };
    }
    return null;
}
//# sourceMappingURL=csfle-library-paths.js.map